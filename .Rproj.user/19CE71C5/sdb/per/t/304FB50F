{
    "contents" : "# Funções de auxilio para a regressão e impressão dos gráficos\n#\n# Marlesson Santana\n#\n\n\n# Path de imagens para salvar\npathImagens <- function(tipo, filename){\n  return(paste(\"Graficos/\",tipo, \"/\", filename, sep = \"\"))\n}\n\n# Definicao do modelo, \nM.predict <- function(modelo, eva, fibra){\n  return(array(modelo$fcc0+predict(modelo, newdata = data.frame(EVA=eva, FIBRA=fibra))))\n}\n\n# Calcula o R2\nQ.R2 <- function(y_pred, y, ...){\n  \n  sqt  <- sum((y     - median(y))^2)\n  \n  sqr  <- Q.SSE(y_pred, y)\n  \n  return( 1 - (sqr / sqt) )\n}\n\n# Calcula o R2\nQ.R2Pred <- function(y, press){\n  \n  sqt  <- sum((y - median(y))^2)\n  \n  return( 1 - (press / sqt) )\n}\n\n# Calcula o soma dos quadrados do resuduo\nQ.SSE <- function(y_pred, y, ...){\n  return( sum((y_pred - y)^2) )\n}\n\n# Calcula o soma dos quadrados do resuduo\nQ.MSE <- function(modelo, y_pred, y, ...){\n  \n  if(is.na(coef(modelo)[\"(Intercept)\"])){\n    coefs <- length(coef(modelo))\n  }else{\n    coefs <- length(coef(modelo)) - 1\n  }\n  \n  return(Q.SSE(y_pred, y)/(length(y)-coefs-1))\n}\n\n# Calcula o PRESS\nQ.PRESS <- function(modelo, y_str, fcc0, dados){\n  press <- 0\n\n  for(i in 1:length(dados$TIPO)){\n    newDados       <- dados[-i, ]\n    \n    ## Calcula o y da regressao\n    newDados['y']  <- newDados[y_str] - fcc0\n      \n    newModelo      <- update(modelo, data=newDados) \n    newModelo$fcc0 <- fcc0\n    \n    newPred        <-  M.predict(newModelo, dados[i, 'EVA'], dados[i, 'FIBRA'])\n    realValue      <-  dados[i, y_str]\n\n    press <- press + (newPred- realValue)^2\n  }\n  \n  return(press)\n}\n\n\n# Plot Residuo Normalizado\nPrintResiduoNormalizado <- function(filename, modelo, residuos, fcc_r, ...){\n  sqe           <- sum(residuos^2)\n  qme           <- sqe/(length(resid(modelo))-length(coef(modelo))-1)\n  \n  nres          <- residuos/sqrt(qme)\n  \n  df    <- data.frame(res=nres, fcc=fcc_r)\n  \n  p <- ggplot(df, aes(x = fcc, y = res)) +  ylim(-2.5, 2.5) +\n    geom_point(size=3.5)+\n    geom_abline(slope = 0, intercept = 2, colour = \"darkred\", linetype = 2, size=0.6) + \n    geom_abline(slope = 0, intercept = 0, colour = \"darkred\", linetype = 2, size=0.7) + \n    geom_abline(slope = 0, intercept = -2, colour = \"darkred\", linetype = 2, size=0.7) + \n    labs(x=\"Valores Ajustados\", y = \"Res\\u{ED}duo Normalizado\")+\n    theme_minimal()+\n    theme(axis.text =element_text(size=15),\n          axis.title=element_text(size=18),\n          plot.title=element_text(size=20, face=\"bold\"))\n  \n  #print(p)\n  \n  ggsave(file=filename)\n}\n\n\n# Plot Residuo EVA\nPrintResiduoVarReg <- function(filename, x_lbl, residuos, var, ...){\n  \n  df    <- data.frame(residuos=residuos, var=var)\n  \n  p <- ggplot(df, aes(x = var, y = residuos))+\n    geom_point(size=3.5)+\n    geom_abline(slope = 0, intercept = 0, colour = \"darkred\", linetype = 2) + \n    labs(x=x_lbl, y = \"Res\\u{ED}duos\")+\n    theme_minimal()+\n    theme(axis.text =element_text(size=12),\n          axis.title=element_text(size=16),\n          plot.title=element_text(size=20,face=\"bold\"))\n  \n  print(p)\n}\n\n\n# Print Grafico da função \nprintModeloAjuste  <- function(filename, modelo, fcc_r, fcc, ylim, xlim, ...){\n\n  #-----------------------------------------------------------------------------\n  # ajuste Pontos\n  pred    <- data.frame(y=fcc,x=fcc_r)\n  m0      <- lm(y~x, data = pred)\n  \n  #-----------------------------------------------------------------------------\n  # fazendo a predição intervalar num grid regular mais fino\n  seq_pred <- seq(min(fcc_r), max(fcc_r), length=10)\n  pred2    <- data.frame(x=seq_pred)\n  pred$x2  <- seq_pred\n  pred$y2  <- predict(m0, newdata=pred2)\n  \n  #str(pred)\n  r2      <- format(c(coef(m0), summary(m0)$r.squared)[3]*100, digits=4)\n\n  #-----------------------------------------------------------------------------\n  #Correla\\u{E7}\\u{00E3}o do Modelo\n  ggplot(pred, aes(x = x, y = y)) +  ylim(ylim) + xlim(xlim) +\n    geom_point(size=3)+\n    geom_line(aes(y=y2, x=x2), colour = \"darkred\", linetype = 2)+\n    geom_text(data = NULL, x =xlim[2], y = ylim[2], \n              label = paste(\"R\\u{00B2}\", r2), size=6)+\n    labs(title=\"Valores Ajustados X Valores Observados\", x=\"Valores Ajustados (MPa)\", y = \"Valores Observados (MPa)\")+\n    theme_minimal()+\n    theme(axis.text =element_text(size=12),\n          axis.title=element_text(size=16),\n          plot.title=element_text(size=20,face=\"bold\"))\n  \n  ggsave(file=filename)\n  \n}\n\n\n# Print grafico 3D Eficiencia\nprint3DEfici <- function(filename, modelo, screen, lbl, lim){\n  \n  # Limite \n  max_eva  <- lim[1]\n  max_fib  <- lim[2]\n  \n  pred       <- expand.grid(bloco=\"I\", EVA=seq(0,max_eva,l=35), FIBRA=seq(0,max_fib,l=35))\n  pred$FCC   <- ((M.predict(modelo,pred$EVA, pred$FIBRA)-M.predict(modelo,pred$EVA,0*pred$FIBRA))/M.predict(modelo,pred$EVA,0*pred$FIBRA))*100\n  pred$EVA   <- pred$EVA*100\n  pred$FIBRA <- pred$FIBRA*100\n  pred <- pred[pred$FCC > 0,]\n  #-----------------------------------------------------------------------------\n  # vendo a superfície ajustada\n  args(panel.3d.contour)\n  body(panel.3d.contour)\n  \n  colr <- brewer.pal(11, \"RdYlGn\")\n  colr <- colorRampPalette(colr, space=\"rgb\")\n  \n  xlab <- lbl[1]\n  ylab <- lbl[2]\n  zlab <- lbl[3]\n  \n  png(file=filename, width=400, height=400)\n  fig <- wireframe(FCC~EVA*FIBRA, data=pred,\n                   scales  =list(arrows=FALSE, axis=list(text=list(cex=1.5))), \n                   main    =list(cex=1.5),\n                   zlab    =list(zlab, rot=90, cex=1.2),\n                   xlab    =list(xlab, rot=24, cex=1.2), \n                   ylab    =list(ylab, rot=-37, cex=1.2),\n                   cex.lab =0.2,\n                   zlim    =c(lim[3],lim[4]), \n                   col     =\"gray50\", \n                   col.contour=1,\n                   panel.3d.wireframe=\"panel.3d.contour\", \n                   type=c(\"on\",\"bottom\"),\n                   col.regions=colr(100),  \n                   drape=TRUE,\n                   screen=screen)\n  print(fig)\n  #\n  dev.off()\n}\n\n\n# Print grafico 3D\nprint3DFunc <- function(filename, modelo, screen, lbl, lim){\n\n  # Limite \n  max_eva  <- lim[1]\n  max_fib  <- lim[2]\n  \n  pred       <- expand.grid(bloco=\"I\", EVA=seq(0,max_eva,l=35), FIBRA=seq(0,max_fib,l=35))\n  pred$FCC   <- M.predict(modelo,pred$EVA,pred$FIBRA)\n  pred$EVA   <- pred$EVA*100\n  pred$FIBRA <- pred$FIBRA*100\n  \n  #-----------------------------------------------------------------------------\n  # vendo a superfície ajustada\n  args(panel.3d.contour)\n  body(panel.3d.contour)\n  \n  colr <- brewer.pal(11, \"RdYlGn\")\n  colr <- colorRampPalette(colr, space=\"rgb\")\n  \n  xlab <- lbl[1]\n  ylab <- lbl[2]\n  zlab <- lbl[3]\n  \n  #png(file=filename, width=850, height=850)\n  fig <- wireframe(FCC~EVA*FIBRA, data=pred,\n            scales  =list(arrows=FALSE, axis=list(text=list(cex=2.5))), \n            main    =list(cex=2),\n            zlab    =list(zlab, rot=90, cex=2),\n            xlab    =list(xlab, rot=24, cex=2), \n            ylab    =list(ylab, rot=-37, cex=2),\n            cex.lab =1.2,\n            zlim    =c(lim[3],lim[4]), \n            col     =\"gray50\", \n            col.contour=1,\n            panel.3d.wireframe=\"panel.3d.contour\", \n            type=c(\"on\",\"bottom\"),\n            col.regions=colr(100),  \n            drape=TRUE,\n            screen=screen)\n  print(fig)\n  #\n  #dev.off()\n}\n\n\n# Cuervas de Nivel G3d\nprintCurvasNivelFunc <- function(filename, modelo, lbl, lim){\n  \n  # Limite \n  max_eva  <- lim[1]\n  max_fib  <- lim[2]\n  \n  colr <- brewer.pal(11, \"RdYlGn\")\n  colr <- colorRampPalette(colr, space=\"rgb\")\n  \n  xlab <- lbl[1]\n  ylab <- lbl[2]\n  zlab <- lbl[3]\n  \n  \n  pred     <- expand.grid(bloco=\"I\", EVA=seq(0,max_eva,l=200), FIBRA=seq(0,max_fib,l=200))\n  pred$FCC <- M.predict(modelo, pred$EVA, pred$FIBRA)\n  pred$EVA   <- pred$EVA*100\n  pred$FIBRA <- pred$FIBRA*100\n  \n  #png(file=filename, width=950, height=850)\n  p <- levelplot(FCC~EVA*FIBRA, data=pred, col.regions=colr(100),\n                 xlab = list(label=xlab, cex=2),\n                 ylab = list(label=ylab, cex=2),\n                 panel= function(..., at, contour=FALSE, labels=NULL){\n                   panel.levelplot(..., at=at, contour=contour, labels=labels)\n                   panel.contourplot(..., at=at, contour=TRUE,\n                                     labels=list(labels=format(at, digits=3), cex=2))\n                 },\n                 par.settings=list(\n                   layout.widths=list(right.padding=4, cex=2)))\n  \n  p$legend$right <- list(fun=mergedTrellisLegendGrob(p$legend$right,\n                                                     list(fun =textGrob, \n                                                          args=list(zlab, rot=-90, x=2)),\n                                                     vertical=FALSE))\n  print(p)\n  #dev.off()\n}\n\n# MAximizando modelo para utilização da fibra\noptimizeFibModelo <- function(modelo, iEva, maximum){\n  \n  # Intervalo de utilização da fibra\n  iFib <- c(-0.0001, 0.0201) \n  \n  \n  fcc_sem_fibra  <- c()\n  fcc_com_fibra  <- c()\n  fib            <- c() \n\n  i <- 1\n  for(eva in iEva){\n    fibMax <- optimize(M.predict, iFib, tol = 0.0001, maximum=maximum, modelo = modelo,  eva = eva)\n    \n    fcc_sem_fibra[i] <- M.predict(modelo,eva,0)\n    if(maximum){\n      fcc_com_fibra[i] <- M.predict(modelo,eva,fibMax$maximum)\n      fib[i]           <- fibMax$maximum    \n    }else{\n      fcc_com_fibra[i] <- M.predict(modelo,eva,fibMax$minimum)\n      fib[i]           <- fibMax$minimum    \n    }\n    \n    i <- i+1\n  }\n  \n  return(list(eva =iEva, fib=fib,fcc_sem_fibra=fcc_sem_fibra,fcc_com_fibra=fcc_com_fibra))\n}\n\n# Plot de Barra do máximo de resistencia com a utlização\n# da fibra\nprintMaxResistenciaFibra <- function(filename, maxFib, lbl_y){\n  #tipo eva    fib           len      fcc\n  #1   SF   0         2.108000e+01 21.08000\n  #2   CF   0        -6.107621e-05 21.07994\n  #3   SF   5         2.061578e+01 20.61578\n  #4   CF   5 0.26 %  9.604657e-02 20.71182\n  #5   SF  10         1.922310e+01 19.22310\n  #6   CF  10 0.52 %  3.841863e-01 19.60729\n  \n  df       <- data.frame()\n\n  # Melhora em porcentagem\n  pMelhora <- round(((maxFib$fcc_com_fibra-maxFib$fcc_sem_fibra)/maxFib$fcc_sem_fibra)*100,2)\n  \n  \n  for (i in seq(1,length(maxFib$eva))) {\n    if(maxFib$fib[i] > 1e-3){\n      fib     <- \"\"\n      melhora <- paste(round(maxFib$fib[i]*100, 2),\"% Fibra\\n\",\"+\",pMelhora[i], \"%\", sep = \"\")\n    }else{\n      fib     <- \"\"\n      melhora <- \"Sem\\nMelhora\"\n    }\n    \n     df <- rbind(df, data.frame(tipo='SF', \n                               eva=maxFib$eva[i]*100, \n                               fib=fib,\n                               cMelhora='',\n                               len = maxFib$fcc_sem_fibra[i],\n                               fcc = maxFib$fcc_sem_fibra[i]))\n    \n  \n    \n    df <- rbind(df, data.frame(tipo='CF', \n                               eva=maxFib$eva[i]*100, \n                               fib='',\n                               cMelhora=melhora,\n                               len= maxFib$fcc_com_fibra[i]-maxFib$fcc_sem_fibra[i],\n                               fcc= maxFib$fcc_com_fibra[i])) \n    \n  }\n  \n \n  p <- ggplot(data=df, aes(x=eva, y=len, fill=tipo)) +\n    geom_bar(stat=\"identity\")+\n    geom_label(aes(y=fcc+0.2,  label=cMelhora), size=4.2, nudge_x = 0.5)+\n    geom_text(aes(y=len+0.05, label=fib), size=4.2, nudge_x = 0.5)+\n    scale_fill_brewer(palette=\"Paired\", labels=c(\"EVA\", \"EVA+Fibra\"))+\n    theme_minimal()+\n    labs(x=\"EVA (%)\", y = lbl_y, fill=\"Tipo\")+\n    theme(axis.text =element_text(size=16),\n          axis.title=element_text(size=16),\n          plot.title=element_text(size=20,face=\"bold\"))\n  \n  print(p)\n  #ggsave(file=filename)\n}\n\n# Retorna um vetor de indices para os pontos de interceptação entre\n# as fuas retas\ninterceptLine <- function(vet1, vet2, error){\n  \n  i = c()\n  \n  for(k in seq(1, length(vet1))){\n    sub <- abs(vet1[k]-vet2[k])\n    \n    i[k] <- (sub < error) \n  }\n  \n  return(i)\n}\n\n# Plot de linha do máximo de resistencia com a utlização\n# da fibra com linha sem utilização da fibra\nprintMaxResistenciaFibraLine <- function(filename, maxFib, lbl_y){\n  df     <- data.frame()\n  \n  for (i in seq(1,length(maxFib$eva))) {\n    df <- rbind(df, data.frame(tipo='CF', \n                               eva=maxFib$eva[i]*100, \n                               fcc= maxFib$fcc_com_fibra[i])) \n    \n    \n    df <- rbind(df, data.frame(tipo='SF', \n                           eva=maxFib$eva[i]*100, \n                           fcc = maxFib$fcc_sem_fibra[i]))\n  }\n  \n\n  p <- ggplot(data=df, aes(x=eva, y=fcc, group=tipo, colour=tipo)) +\n    geom_line()+\n    scale_fill_brewer(palette=\"Paired\", labels=c(\"EVA\", \"EVA+Fibra\"))+\n    theme_minimal()+\n    labs(title=\"Maximiza\\u{E7}\\u{E3}o da Resist\\u{00EA}ncia com a Utiliza\\u{E7}\\u{E3}o da Fibra\", \n         x=\"EVA (%)\", y = lbl_y, colour=\"Tipo\")+\n    theme(axis.text =element_text(size=12),\n          axis.title=element_text(size=16),\n          plot.title=element_text(size=20,face=\"bold\"))\n\n  #Pontos de divisão\n  intercept_lines <- interceptLine(maxFib$fcc_sem_fibra, maxFib$fcc_com_fibra, error=1e-02)\n  \n  # Se tiver intercecção com as linhas\n  if(length(which(intercept_lines)) > 0){\n    i_max   <- max(which(intercept_lines))\n    \n    x1 <- maxFib$eva[i_max]*100\n    y1 <- maxFib$fcc_com_fibra[i_max]\n    points_inter <- data.frame(tipo='CF',eva = x1, fcc = y1)    \n\n    # Plot point\n    p <- p + geom_point(data=points_inter, colour=\"red\") +\n      geom_text(data=head(points_inter, 1), \n                label=paste(\"(\",round(x1, 2),\", \", round(y1,2),\")\", sep = \"\"), \n                colour = \"black\", size=4, hjust=1)    \n  }\n  \n  \n  #print(p)  \n  \n  ggsave(file=filename)\n}\n\n# Plot de linha com valores de fibra 0, 1 e 2 \nprintResistenciaFibraLinha <- function(filename, modelo, lbl_y){\n  iEva     <- seq(0, 0.25, by=0.0025)\n\n  fcc_0    <- M.predict(modelo,iEva, rep(0,    length(iEva)))\n  fcc_1    <- M.predict(modelo,iEva, rep(0.01, length(iEva)))\n  fcc_2    <- M.predict(modelo,iEva, rep(0.02, length(iEva)))\n  \n  df     <- data.frame()\n  \n  for (i in seq(1,length(iEva))) {\n    df <- rbind(df, data.frame(tipo='SF', \n                               eva = iEva[i]*100, \n                               fcc = fcc_0[i]))\n    \n    df <- rbind(df, data.frame(tipo='CF1', \n                               eva=iEva[i]*100, \n                               fcc=fcc_1[i]))\n    \n    \n    df <- rbind(df, data.frame(tipo='CF2', \n                               eva=iEva[i]*100, \n                               fcc=fcc_2[i])) \n  }\n  \n  \n  p <- ggplot(data=df, aes(x=eva, y=fcc, group=tipo, colour=tipo)) +\n    geom_line()+\n    scale_fill_brewer(palette=\"Paired\", labels=c(\"EVA\", \"EVA+Fibra\"))+\n    theme_minimal()+\n    labs(title=\"Resist\\u{00EA}ncia X EVA\", x=\"EVA (%)\", \n         y = lbl_y, colour=\"Tipo\")+\n    theme(axis.text =element_text(size=12),\n          axis.title=element_text(size=16),\n          plot.title=element_text(size=20,face=\"bold\"))\n  \n  \n  # Verifica se tem ponto de intercepcao\n  intercept_lines <- interceptLine(fcc_0, fcc_1, error=1e-01)\n  \n  # Se tiver intercecção com as linhas fcc_0, fcc_1\n  if(length(which(intercept_lines)) > 0){\n    i_max   <- median(which(intercept_lines))\n    \n    x1 <- iEva[i_max]*100\n    y1 <- fcc_0[i_max]\n    points_inter <- data.frame(tipo='CF2',eva = x1, fcc = y1)    \n    \n    # Plot point\n    p <- p + geom_point(data=points_inter, colour=\"red\") +\n      geom_text(data=head(points_inter, 1), \n                label=paste(\"(\",round(x1, 2),\", \", round(y1,2),\")\", sep = \"\"), \n                colour = \"black\", size=4, hjust=1)    \n  }\n\n  intercept_lines <- interceptLine(fcc_0, fcc_2, error=1e-01)\n  \n  # Se tiver intercecção com as linhas fcc_0, fcc_1\n  if(length(which(intercept_lines)) > 0){\n    i_max   <- median(which(intercept_lines))\n    \n    x1 <- iEva[i_max]*100\n    y1 <- fcc_0[i_max]\n    points_inter <- data.frame(tipo='CF2',eva = x1, fcc = y1)    \n    \n    # Plot point\n    p <- p + geom_point(data=points_inter, colour=\"red\") +\n      geom_text(data=head(points_inter, 1), \n                label=paste(\"(\",round(x1, 2),\", \", round(y1,2),\")\", sep = \"\"), \n                colour = \"black\", size=4, hjust=1)    \n  }\n  \n  #print(p)\n  \n  ggsave(file=filename)\n}\n\n\n# Plot de linha com valores de eva 5, 15, 25\nprintResistenciaEVALinha <- function(filename, modelo, lbl_y){\n  iFib     <- seq(0, 0.02, by=0.00025)\n  \n  fcc_0    <- M.predict(modelo, rep(0.05, length(iFib)), iFib)\n  fcc_1    <- M.predict(modelo, rep(0.15, length(iFib)), iFib)\n  fcc_2    <- M.predict(modelo, rep(0.25, length(iFib)), iFib)\n  \n  df     <- data.frame()\n  \n  for (i in seq(1,length(iFib))) {\n    df <- rbind(df, data.frame(tipo='EVA5', \n                               fib = iFib[i]*100, \n                               fcc = fcc_0[i]))\n    \n    df <- rbind(df, data.frame(tipo='EVA15', \n                               fib=iFib[i]*100, \n                               fcc=fcc_1[i]))\n    \n    \n    df <- rbind(df, data.frame(tipo='EVA25', \n                               fib=iFib[i]*100, \n                               fcc=fcc_2[i])) \n  }\n  \n  #Pontos de intercecção\n  y  <- min(abs(fcc_0-fcc_1))\n  i  <- which(abs(fcc_0-fcc_1) == y)\n  x1 <- iFib[i]*100\n  y1 <- fcc_0[i]\n  \n  y <- min(abs(fcc_2-fcc_0))\n  i  <- which(abs(fcc_2-fcc_0) == y)\n  x2 <- iFib[i]*100\n  y2 <- fcc_0[i]\n  \n  p <- ggplot(data=df, aes(x=fib, y=fcc, group=tipo, colour=tipo)) +\n    geom_line()+\n    scale_fill_brewer(palette=\"Paired\", labels=c(\"EVA\", \"EVA+Fibra\"))+\n    theme_minimal()+\n    labs(title=\"Resist\\u{00EA}ncia X Fibra\", x=\"Fibra (%)\", \n         y = lbl_y, colour=\"Tipo\")+\n    theme(axis.text =element_text(size=12),\n          axis.title=element_text(size=16),\n          plot.title=element_text(size=20,face=\"bold\"))\n\n  \n  # print(p)\n  \n  ggsave(file=filename)\n}\n\n# Multiple plot function\n#\n# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)\n# - cols:   Number of columns in layout\n# - layout: A matrix specifying the layout. If present, 'cols' is ignored.\n#\n# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),\n# then plot 1 will go in the upper left, 2 will go in the upper right, and\n# 3 will go all the way across the bottom.\n#\nmultiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {\n  library(grid)\n  \n  # Make a list from the ... arguments and plotlist\n  plots <- c(list(...), plotlist)\n  \n  numPlots = length(plots)\n  \n  # If layout is NULL, then use 'cols' to determine layout\n  if (is.null(layout)) {\n    # Make the panel\n    # ncol: Number of columns of plots\n    # nrow: Number of rows needed, calculated from # of cols\n    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),\n                     ncol = cols, nrow = ceiling(numPlots/cols))\n  }\n  \n  if (numPlots==1) {\n    print(plots[[1]])\n    \n  } else {\n    # Set up the page\n    grid.newpage()\n    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))\n    \n    # Make each plot, in the correct location\n    for (i in 1:numPlots) {\n      # Get the i,j matrix positions of the regions that contain this subplot\n      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))\n      \n      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,\n                                      layout.pos.col = matchidx$col))\n    }\n  }\n}",
    "created" : 1470870767635.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "2620258144",
    "id" : "304FB50F",
    "lastKnownWriteTime" : 1477488473,
    "path" : "D:/Dropbox/Mestrado/Projeto Marlesson/Dissertacao/Algoritimos R/Concreto/lib/msFunc.r",
    "project_path" : "lib/msFunc.r",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}